### 16236 - 아기 상어

# 사용된 알고리즘 :
	1. BFS
	2. Priority_queue

# 해결 목표 :
	1. 아기상어는 가장 가까운 물고기를 먹으러 움직인다.
	2. 아기상어는 자신보다 몸집이 큰 물고기가 있는 자리를 지나갈 수 없다.
	3. 아기상어는 자신보다 작은 물고기만 먹을 수 있다.
	4. 아기상어는 자신의 몸집과 같은 수의 물고기를 먹으면 몸집이 1만큼 커진다.
	5. 아기상어는 거리가 같은 물고기들이 여러마리라면 위에 있는 물고기부터, 또 여러마리라면 왼쪽부터 먹으러 움직인다.

# 해결해야 할 부분 :
	1. 가장 가까운 물고기, 지나갈 수 없는 자리
	-> 이 두가지를 해결하려면 BFS로 가는 것이 가장 유리할 것이다.
	

	2. 지나갈 수 있는 자리와 먹을 수 있는 물고기의 자리
	-> 1) 상어의 몸집의 크기를 저장해야한다.
	-> 2) 상어의 몸집의 크기로 지나갈 수 있는 조건과 먹을 수 있는 조건을 만든다.


	3. 몸집의 크기와 같은 먹은 물고기 수 => Size Up
	-> 먹은 물고기의 수도 저장해야한다.


	4. 가장 가까운 거리의 물고기부터, 같은 거리에 먹을 수 있는 물고기가 여러 마리라면 위부터, 또 중복된다면 왼쪽부터.
	-> 일반적인 queue로 돌리니 답에 맞지 않게 나왔다. 
	
	-> 1) 처음에는 반시계방향으로 먼저 가게끔 dx,dy를 만들었다. 하지만,
	-> 2) 상어가 바다의 맨 위까지 올라갔을 때 2칸 거리가 가장 가까운 거리라면 오른쪽 위가 아닌 왼쪽 아래를 먹으러 간다.

	ex) ㅁ	ㅁ	s	ㅁ	f
		f	ㅁ	ㅁ	ㅁ	ㅁ
	-> 오른쪽 물고기를 먼저 먹어야함. 같은 거리에 위에 있기 때문.

	-> 3) Priority_queue가 필요하다.


	5. sort와 Priority_queue의 조건은 만드는 방법이 같을 까?
	-> 다르다.

	-> sort는 함수의 형태로 만든다. 
		"bool cmp(type data1, type data2) return ... ;"
		정렬 시에 : "sort(v.begin(),v.end(),cmp);"

	-> queue는 구조체의 형태로 만든다. 
		"struct cmp{
			bool operator()(type data1, type data2){
				return ... ;
			}
		}"
		선언 시에 : "priority_queue <type, vector<type>, cmp> q;"


	6. 오름차순은 부등호 방향이?
	-> "bool operator()(type d1, type d2){
	
	}" -> 에서 오름차순은 (작은 것 부터 먼저 나오게) return d1 < d2, return d1 > d2 중에서 어느 것일 까?
	-> 정답은 후자다. (return d1 > d2) 


	7. 넣고 확인?, 넣으면서 확인?
	-> 먼저 나오는 것이 아닌 갈 수 있는 곳들에서 조건에 해당하는 경우를 택해야한다.
	-> 조건은 이미 만들어 놨으니,
	-> 넣고 나서 확인하는 것이 맞다.