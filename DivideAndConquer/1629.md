### 1629(No.) - 곱셈(Title)

# 사용된 알고리즘(Algorithm Used) :
	1. 정수론
	-> Euler theorem

	2. 분할 정복을 이용한 곱셈
	-> Multiply using Divide & Conquer

# 해결 목표(Goal) :
	1. A를 B번 제곱하여 C로 나눈 나머지를 구하시오.
	-> Multiply A by B times and find remainder of dividing by C

# 해결해야 할 부분(Problem needed to be Adressed) :
	1. Euler theorem && Overflow
	-> 1) 4 bytes를 필요로 하는 int 자료형의 제곱(2^31 - 1)은 8 bytes를 필요로 하는 long long 자료형(2^63 - 1)으로 표현 가능하다.
		en) The square of int data type that requires 4 bytes(2^31 - 1) can be expressed as a long long data type(2^63 - 1).

	-> 2) 하지만 세제곱 이상은 Overflow가 일어난다. 이때 필요한 것이 modular 연산에 대한 Euler theorem이다.
		en) But, if it is more than cube, Overflow occurs. In this case, what is needed is Euler theorem for modular arithmetic.

	-> 3) (B * C) mod D = B mod D * C mod D 이다.  
	-> 4) 따라서, A = B * C 이면, A mod D = (B * C) mod D 이고, 
	-> 5) A mod D = B mod D * C mod D 이다.

	-> 6) 이를 통해 int * int를 Overflow 없이 remainder를 구할 수 있다. 
		en) This allow int * int to get remainder without Overflow.


	2. 시간 복잡도 (Time Complexity) 
	-> 2,147,483,647. 약 21억이라는 숫자는 너무 크므로, 반드시 O(log N)으로 시간 복잡도를 낮추어야 한다.
		en) The number of 2.1 billion is too large, We must reduce Time Complexity to O(log N).

	-> 시간 복잡도를 log N으로 줄여야한다는 것, mod 연산을 사용해서 푸는 문제인 것은 알았는데 구현 방법을 알지 못했다.
		en) I knew that Time Complexity had to be reduced to log N and it was problem to be solved using mod operation,	but I didn't know how to implement it.
	

	3. 구현을 위한 아이디어(Idea for Implementation) 
	-> log N으로 가는 가장 간단한 방법은 계속해서 2로 나누는 것이다.(이분 탐색처럼)
		en) The simplest way to O(log N) is to keep dividing by 2.(like Binary Search)

	-> 1-1) A^B 
			= A ^ (B/2) ^ 2 (when B % 2 == 0)

	-> 1-2) A^B mod C 
			= {A ^ (B/2) ^ 2}mod C 

	-> 2-1) A^B 
			= {A ^ (B/2) ^ 2} * A (when B % 2 != 0)

	-> 2-2) A^B mod C 
			= [{A ^ (B/2) ^ 2}mod C * A] mod C 